#+TITLE: Nadav Spiegelman's Emacs config
* Introduction
This is my Emacs configuration set up as an Org file. As a convert from Vim, I make heavy use of Evil.

Inspired by [[https://github.com/mwfogleman/config/blob/master/home/.emacs.d/michael.org][mwfogleman]], [[https://github.com/daschwa/dotfiles/blob/master/emacs.d/emacs-init.org][daschwa]], [[https://github.com/TheBB/dotfiles/blob/master/emacs/init.el][TheBB]], and others.
* General setup
** Package management
Set up package and req-package so the rest of this can work. Install req-package if it isn't already.
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.org/packages/") t)
  (package-initialize)

  (if (not (package-installed-p 'req-package))
      (progn
        (package-refresh-contents)
        (package-install 'req-package)))

  (require 'req-package)
#+END_SRC
** Basic settings
*** Remove scrollbars, menu bars, toolbars
#+BEGIN_SRC emacs-lisp
    (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
    (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

*** Quiet startup
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t
      inhibit-startup-echo-area-message t
      initial-scratch-message nil)
#+END_SRC

*** Turn off alarms
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

*** Use UTF-8
#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
#+END_SRC
*** Put backups and autosave files in tmp dir
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+END_SRC
*** Quicker prompts
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Remove nonexistent file confirmation
#+BEGIN_SRC emacs-lisp
  (setq confirm-nonexistent-file-or-buffer nil)
#+END_SRC
*** Enable directory local variables for remote files
I will use .dir-locals.el to turn on projectile cache for large projects.
#+BEGIN_SRC emacs-lisp
  (setq enable-remote-dir-locals t)
#+END_SRC
** Editing settings
*** Turn off blinking cursor
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC
*** Highlight current line
Like cursorline in Vim

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC
*** Indicate empty lines
#+BEGIN_SRC emacs-lisp
(setq default-indicate-empty-lines t)
#+END_SRC
*** Delete trailing whitespace on save
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC
*** Indentation settings
Indent using spaces instead of tabs and use 4 spaces by default.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq tab-width 4)
#+END_SRC
*** Uniquify buffers with the same filename

#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq
  uniquify-buffer-name-style 'post-forward
  uniquify-separator ":")
#+END_SRC
*** Column markers

#+BEGIN_SRC emacs-lisp
(req-package column-marker
  :config
  (progn
    (column-marker-1 80)
    (column-marker-2 120)))
#+END_SRC
*** Hippie expand
#+BEGIN_SRC emacs-lisp
(bind-key "M-/" 'hippie-expand)
(setq hippie-expand-try-functions-list
      '(try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-file-name-partially
        try-complete-file-name
        try-expand-all-abbrevs
        try-expand-list
        try-expand-line
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))
#+END_SRC
*** Global auto revert
#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)
#+END_SRC
*** Flycheck
#+BEGIN_SRC emacs-lisp
  (require 'flycheck)

  ;; turn on flychecking globally
  (add-hook 'after-init-hook #'global-flycheck-mode)

  ;; disable jshint since we prefer eslint checking
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint)))

  ;; use eslint with web-mode for jsx files
  (flycheck-add-mode 'javascript-eslint 'web-mode)
#+END_SRC
** Mac
*** Use command key as meta

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq mac-command-modifier 'meta))
#+END_SRC
*** Font settings
#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (set-face-attribute 'default nil :height 170)
    (set-default-font "Input Mono")
    (setq-default line-spacing 0.25)
    (setq-default word-wrap t))
#+END_SRC
*** Use $PATH

#+BEGIN_SRC emacs-lisp
(when (memq window-system '(mac ns))
  (req-package exec-path-from-shell
    :init
    (exec-path-from-shell-initialize)))
#+END_SRC
** Key bindings
General key bindings not necessarily tied to any packages.

*** Indent on RET like a sane person

#+BEGIN_SRC emacs-lisp
(bind-key "RET" 'newline-and-indent)
#+END_SRC

*** Use M-h for help
Because we're going to override the default bind to switch windows

#+BEGIN_SRC emacs-lisp
(bind-key "M-h" 'help)
#+END_SRC

*** Window splits

#+BEGIN_SRC emacs-lisp
(defun split-and-switch-horizontally ()
  (interactive)
  (split-window-horizontally)
  (other-window 1))

(defun split-and-switch-vertically ()
  (interactive)
  (split-window-vertically)
  (other-window 1))

(bind-key  "M-3" 'split-and-switch-horizontally)
(bind-key  "M-2" 'split-and-switch-vertically)
(bind-key  "M-1" 'delete-other-windows)
(bind-key  "M-0" 'delete-window)
(bind-key  "M-o" 'other-window)
#+END_SRC

*** Escape from everything
Use esc to get away from everything, like in vim
https://github.com/TheBB/dotfiles/blob/master/emacs/init.el

#+BEGIN_SRC emacs-lisp
(defun bb/minibuffer-keyboard-quit ()
  (interactive)
  (if (and delete-selection-mode transient-mark-mode mark-active)
      (setq deactivate-mark t)
    (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
    (abort-recursive-edit)))
(define-key minibuffer-local-map [escape] 'bb/minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'bb/minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'bb/minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'bb/minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'bb/minibuffer-keyboard-quit)
#+END_SRC
* Install Packages
The good stuff
** Evil and family
*** Enable C-u scrolling
Must be set before evil is loaded and use-package's :pre-load isn't working for some reason.

#+BEGIN_SRC emacs-lisp
(setq evil-want-C-u-scroll t
      evil-want-C-w-in-emacs-state t)
#+END_SRC

*** Surround
#+BEGIN_SRC emacs-lisp
(req-package evil-surround
  :init (global-evil-surround-mode t))
#+END_SRC

*** Evil mode
#+BEGIN_SRC emacs-lisp
  (req-package evil
    :require evil-surround
    :config
    (evil-mode t)

    ;; map multiple states at once (courtesy of Michael Markert;
    ;; http://permalink.gmane.org/gmane.emacs.vim-emulation/1674)
    (defun set-in-all-evil-states (key def &optional maps)
      (unless maps
        (setq maps (list evil-normal-state-map
                         evil-visual-state-map
                         evil-insert-state-map
                         evil-emacs-state-map
                         evil-motion-state-map)))
      (while maps
        (define-key (pop maps) key def)))

    (defun set-in-all-evil-states-but-insert (key def)
      (set-in-all-evil-states key def (list evil-normal-state-map
                                            evil-visual-state-map
                                            evil-emacs-state-map
                                            evil-motion-state-map)))
    ;; colemak stuff
    (set-in-all-evil-states-but-insert "e" 'evil-previous-line)
    (set-in-all-evil-states-but-insert "n" 'evil-next-line)
    (set-in-all-evil-states-but-insert "i" 'evil-forward-char)

    (set-in-all-evil-states-but-insert "U" 'evil-insert-line)
    (set-in-all-evil-states-but-insert "u" 'evil-insert)
    (set-in-all-evil-states-but-insert "l" 'undo-tree-undo)

    (define-key evil-motion-state-map "k" 'evil-search-next)
    (define-key evil-motion-state-map "K" 'evil-search-previous)

    (define-key evil-motion-state-map "j" 'evil-forward-word-end)
    ;; (define-key evil-motion-state-map "J" 'evil-forward-WORD-end)

    (define-key evil-insert-state-map (kbd "C-e") 'move-end-of-line)

    (define-key evil-normal-state-map (kbd ",") 'ace-jump-char-mode)

    (setq evil-emacs-state-cursor  '("red" box))
    (setq evil-normal-state-cursor '("orange" box))
    (setq evil-visual-state-cursor '("green" box))
    (setq evil-insert-state-cursor '("orange" bar))
    (setq evil-replace-state-cursor '("orange" bar))
    (setq evil-operator-state-cursor '("orange" hollow))
    (setq evil-motion-state-cursor '("gray" box))

    (define-key evil-normal-state-map (kbd ";") 'evil-ex)
    (define-key evil-visual-state-map (kbd ";") 'evil-ex)
    (define-key evil-normal-state-map (kbd ":") 'evil-repeat-find-char)

    (define-key evil-normal-state-map (kbd "gei")
      (lambda () (interactive) (find-file user-init-file)))
    (define-key evil-normal-state-map (kbd "geb")
      'eval-buffer)
    (define-key evil-normal-state-map (kbd "geh")
      (lambda () (interactive) (find-file "/sudo::/etc/hosts")))

    ;; Easier window switching
    (defun evil-window-keymaps (map)
      (define-key map (kbd "C-k") 'evil-window-up)
      (define-key map (kbd "C-j") 'evil-window-down)
      (define-key map (kbd "C-h") 'evil-window-left)
      (define-key map (kbd "C-l") 'evil-window-right))
    (evil-window-keymaps evil-normal-state-map))
#+END_SRC

*** Leader

#+BEGIN_SRC emacs-lisp
  (req-package evil-leader
    :require evil
    :config
    (evil-leader/set-leader "SPC")
    (setq evil-leader/in-all-states)
    (global-evil-leader-mode t)

    (evil-leader/set-key "h" 'help)

    ;; define and name prefixes, courtesy of spacemacs
    (dolist (x '(("t" . "toggles")
                 ("o" . "org")
                 ("w" . "windows")))
      (let ((key (car x))
            (prefix-command (intern (format "%s-prefix" (cdr x)))))
        (define-prefix-command prefix-command)
        (evil-leader/set-key key prefix-command)))

    ;; files
    ;;(evil-leader/set-key "fs" 'save-buffer)

    (evil-leader/set-key "tv" 'variable-pitch-mode)

    ;; window management
    (evil-leader/set-key
      "ww" 'split-and-switch-horizontally
      "wv" 'split-and-switch-vertically
      "wc" 'delete-window
      "wo" 'delete-other-windows)

    ;; ace jump mode
    (evil-leader/set-key "e" 'evil-ace-jump-word-mode)
    (evil-leader/set-key "l" 'evil-ace-jump-line-mode)
    (evil-leader/set-key "j" 'evil-ace-jump-char-mode)

    ;; switch to previous buffer with <leader>SPC
    (evil-leader/set-key
      "SPC" 'mode-line-other-buffer))
#+END_SRC

*** Evil-nerd-commenter
#+BEGIN_SRC emacs-lisp
  (req-package evil-nerd-commenter
    :init (setq evilnc-hotkey-comment-operator "gc")
    :require evil-leader)
#+END_SRC

*** Matchit
#+BEGIN_SRC emacs-lisp
(req-package evil-matchit
  :require evil
  :config
  (defun evilmi-customize-keybinding ()
    (evil-define-key 'normal evil-matchit-mode-map
      (kbd "TAB") 'evilmi-jump-items))

  (global-evil-matchit-mode t))
#+END_SRC

*** Evil-args
#+BEGIN_SRC emacs-lisp
  (req-package evil-args
    :require evil
    :config
    ;; bind evil-args text objects
    (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
    (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)

    ;; bind evil-forward/backward-args
    (define-key evil-normal-state-map "I" 'evil-forward-arg)
    (define-key evil-normal-state-map "H" 'evil-backward-arg)
    (define-key evil-motion-state-map "I" 'evil-forward-arg)
    (define-key evil-motion-state-map "H" 'evil-backward-arg)

    ;; bind evil-jump-out-args
    (define-key evil-normal-state-map (kbd "gE") 'evil-jump-out-args)
    )
#+END_SRC

*** Key chord
Define the jk chord to switch to normal mode and save the buffer

#+BEGIN_SRC emacs-lisp
(req-package key-chord
  :require evil
  :config
  (key-chord-mode t)
  (defun evil-normal-and-save-buffer()
    (interactive)
    (evil-normal-state)
    (save-buffer))

  (key-chord-define evil-insert-state-map "dt" 'evil-normal-and-save-buffer)
  (key-chord-define evil-visual-state-map "dt" 'evil-normal-and-save-buffer))
#+END_SRC

*** Sneak
#+BEGIN_SRC emacs-lisp
(req-package evil-sneak
  :require evil
  :load-path "vendor/")
#+END_SRC

*** Evil-escape
Binds a key chord (`fd`) to escape from all the things

#+BEGIN_SRC emacs-lisp
  (req-package evil-escape
    :disabled
    :require evil
    :init
    (evil-escape-mode t))
#+END_SRC

** Relative line numbers
Like in Vim. Set globally.
Show the actual line number for the current line.
#+BEGIN_SRC emacs-lisp
  (req-package linum-relative
    :require evil-leader
    :init
    (setq linum-format 'linum-relative)
    :config
    (global-linum-mode 1)
    (evil-leader/set-key "tr" 'linum-relative-toggle))
#+END_SRC
** Ido
I mostly use Helm but there are places where ido still comes in handy

#+BEGIN_SRC emacs-lisp
(req-package ido-ubiquitous
  :config (ido-ubiquitous-mode 1))

(req-package flx-ido)

(req-package ido-vertical-mode)

(ido-mode t)
(ido-everywhere t)
(ido-vertical-mode 1)
(flx-ido-mode t)
(setq ido-enable-flex-matching t)
(setq ido-use-faces nil)
#+END_SRC
** Magit
#+BEGIN_SRC emacs-lisp
  (req-package magit
    :require evil-leader

    :config
    (progn
      (evil-add-hjkl-bindings magit-branch-manager-mode-map 'emacs
        "K" 'magit-discard-item
        "L" 'magit-key-mode-popup-logging)
      (evil-add-hjkl-bindings magit-status-mode-map 'emacs
        "K" 'magit-discard-item
        "l" 'magit-key-mode-popup-logging
        "h" 'magit-toggle-diff-refine-hunk)
      (evil-add-hjkl-bindings magit-log-mode-map 'emacs)
      (evil-add-hjkl-bindings magit-commit-mode-map 'emacs)

      ;; full screen magit-status
      (defadvice magit-status (around magit-fullscreen activate)
        (window-configuration-to-register :magit-fullscreen)
        ad-do-it
        (delete-other-windows))

      (defadvice magit-mode-quit-window (after magit-restore-screen activate)
        "Restores the previous window configuration and kills the magit buffer"
        (jump-to-register :magit-fullscreen))

      (define-key magit-status-mode-map (kbd "q") 'magit-mode-quit-window)

      (evil-set-initial-state 'git-commit-mode 'insert)

      (defun evil-git-add-current-file ()
        (interactive)
        (start-process "git-add"
                       (get-buffer-create "*git-add*")
                       "git" "add" buffer-file-name)
        (find-file-noselect buffer-file-name)
        (message "File added"))

      (defun evil-git-checkout-current-file ()
        (interactive)
        (start-process "git-checkout"
                       (get-buffer-create "*git-checkout*")
                       "git" "checkout --" buffer-file-name)
        (find-file-noselect buffer-file-name))

      (defun evil-get-remove-current-file ()
        (interactive)
        (start-process "git-remove"
                       (get-buffer-create "*git-remove*")
                       "git" "rm" "-f"
                       buffer-file-name)
        (kill-buffer))

      (evil-leader/set-key "ga" 'evil-git-add-current-file)

      (evil-ex-define-cmd "Gread" 'evil-git-checkout-current-file)
      (evil-ex-define-cmd "Gremove" 'evil-git-remove-current-file)

      (evil-leader/set-key
        "gs" 'magit-status
        "gp" 'magit-push
        "gb" 'magit-blame-mode
        "gd" 'vc-diff
        "gl" 'magit-log
        "gc" (lambda ()
               (interactive)
               (minibuffer-with-setup-hook
                   (lambda () (backward-char 1))
                 (evil-ex "!git commit -m \"\""))))))
#+END_SRC
*** Magit git flow
#+BEGIN_SRC emacs-lisp
  (req-package magit-gitflow
    :require magit
    :config
    (add-hook 'magit-mode-hook 'turn-on-magit-gitflow))
#+END_SRC
** Helm
#+BEGIN_SRC emacs-lisp
  (req-package helm
    :require evil-leader
    :config
    (progn
      (helm-mode 1)

      ;; don't show . and .. when using find-file
      (setq helm-boring-file-regexp-list '("\\.\\.$" "\\.$"))
      (setq helm-ff-skip-boring-files t)

      (evil-leader/set-key "b" 'helm-mini)
      (evil-leader/set-key "f" 'helm-find-files)
      (evil-leader/set-key "r" 'helm-recentf)

      (global-set-key (kbd "C-x C-m") 'helm-M-x)
      (evil-leader/set-key "x" 'helm-M-x)


      (define-key evil-normal-state-map (kbd "ghb") 'helm-bookmarks)
      (define-key evil-normal-state-map (kbd "g h i") 'helm-semantic-or-imenu)
      (define-key evil-normal-state-map (kbd "g h o") 'helm-occur)

      ;; hjkl navigation courtesy of spacemacs
      ;; (define-key helm-map (kbd "C-j") 'helm-next-line)
      (define-key helm-map (kbd "C-e") 'helm-previous-line)
      (define-key helm-map (kbd "C-h") 'helm-next-source)
      (define-key helm-map (kbd "C-i") 'helm-previous-source)

      (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
      (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
      (define-key helm-map (kbd "C-z") 'helm-select-action)))

  (req-package helm-ag
    :require helm)

  (req-package helm-projectile
    :require (helm projectile)
    :config
    (progn
      ;;(define-key evil-normal-state-map (kbd "C-p") 'helm-projectile)
      (evil-leader/set-key "p" 'helm-projectile)

      (setq projectile-completion-system 'helm)
      (helm-projectile-on)
      (setq helm-projectile-sources-list '(
                                           helm-source-projectile-files-list
                                           helm-source-projectile-projects
                                           ))
      (setq projectile-switch-project-action 'helm-projectile)
      ))
#+END_SRC
** Projectile
To turn on caching for a project, create a =.dir-locals.el= file with:
#+BEGIN_SRC text
((nil . ((projectile-enable-caching . t))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (req-package projectile
    :config
    (progn
      (projectile-global-mode)
      (evil-leader/set-key "a g" 'projectile-ag)
      ))
#+END_SRC
** Working with text
*** Rainbow delimiters
#+BEGIN_SRC emacs-lisp
(req-package rainbow-delimiters
  :init (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC
*** Smartparens

#+BEGIN_SRC emacs-lisp
  (req-package smartparens
    :config
    (progn
      (require 'smartparens-config)
      (setq sp-autoescape-string-quote nil)
      (defun prelude-smart-open-line-above ()
        "Insert an empty line above the current line.
  Position the cursor at it's beginning, according to the current mode."
        (interactive)
        (move-beginning-of-line nil)
        (newline-and-indent)
        (forward-line -1)
        (indent-according-to-mode))
      (sp-pair "{" nil :post-handlers
               '(((lambda (&rest _ignored)
                    (prelude-smart-open-line-above)) "RET")))
      (show-smartparens-global-mode t)
      (smartparens-global-mode t)))
#+END_SRC
*** Aggressive indent mode

#+BEGIN_SRC emacs-lisp
(req-package aggressive-indent
  :config
  (progn
    (eval-after-load 'scss-mode
      '(add-hook
        'scss-mode-hook
        (lambda () (unless defun-prompt-regexp
                     (setq-local defun-prompt-regexp "^[^[:blank:]].*")))))
    (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
    (add-hook 'css-mode-hook #'aggressive-indent-mode)))
#+END_SRC

*** Move-text
#+BEGIN_SRC emacs-lisp
(req-package move-text)
#+END_SRC

** Code completion
*** Company
#+BEGIN_SRC emacs-lisp
  (req-package company
    :config
    (progn
      (setf company-idle-delay 0
            company-minimum-prefix-length 2
            company-show-numbers t
            company-selection-wrap-around t
            company-dabbrev-ignore-case t
            company-dabbrev-ignore-invisible t
            company-dabbrev-downcase nil)

      (define-key company-active-map (kbd "C-n") 'company-select-next)
      (define-key company-active-map (kbd "C-e") 'company-select-previous)
      (global-company-mode t)))
#+END_SRC

*** Emmet
#+BEGIN_SRC emacs-lisp
(req-package emmet-mode
  :commands emmet-mode
  :init
  (add-hook 'sgml-mode-hook 'emmet-mode)
  (add-hook 'css-mode-hook  'emmet-mode)
  (add-hook 'nxml-mode-hook  'emmet-mode)
  (add-hook 'web-mode-hook  'emmet-mode)
  :config
  (setq emmet-preview-default nil)

  (define-key evil-insert-state-map (kbd "C-k") 'emmet-expand-line))
#+END_SRC

*** Yasnippet
#+BEGIN_SRC emacs-lisp
  (req-package yasnippet
    :config
    (progn
      (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
      (define-key evil-insert-state-map (kbd "C-s") 'yas-expand)
      (setq yas-fallback-behavior 'return-nil)
      (define-key yas-minor-mode-map (kbd "<tab>") nil)
      (define-key yas-minor-mode-map (kbd "TAB") nil)
      (yas-global-mode 1)))

#+END_SRC
** Development modes
*** CSS mode
#+BEGIN_SRC emacs-lisp
(req-package css-mode
  :config
  (setq css-indent-offset 2))
#+END_SRC

*** SCSS mode
#+BEGIN_SRC emacs-lisp
  (req-package scss-mode
    :require css-mode
    :config
    (progn
      (setq scss-compile-at-save nil)
      ;;(add-hook 'scss-mode-hook 'flycheck-mode)
      (add-hook 'scss-mode-hook (lambda ()
                                  (setq comment-start "// " comment-end "")
                                  (setq require-final-newline t)
                                  ))))
#+END_SRC
*** Rainbow mode
Colorizes colors in CSS
#+BEGIN_SRC emacs-lisp
(req-package rainbow-mode
  :require css-mode
  :config
  (add-hook 'css-mode-hook 'rainbow-mode))
#+END_SRC
*** js2 mode
#+BEGIN_SRC emacs-lisp
  (req-package js2-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
    (custom-set-variables
     '(js2-basic-offset 2)
     '(js2-bounce-indent-p nil))

    (defun modify-syntax-table-for-jsx ()
      (modify-syntax-entry ?< "(>")
      (modify-syntax-entry ?> ")<"))

    (add-hook 'js2-mode-hook 'modify-syntax-table-for-jsx))
#+END_SRC
*** Web mode
#+BEGIN_SRC emacs-lisp
  (req-package web-mode
    :config
    (progn
      (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.[gj]sp\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.jsx$" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))

      (add-hook 'web-mode-hook
                (lambda ()
                  (setq indent-tabs-mode t)))

      (setq web-mode-code-indent-offset 2)
      (setq web-mode-markup-indent-offset 4)

      (defadvice web-mode-highlight-part (around tweak-jsx activate)
        (if (equal web-mode-content-type "jsx")
            (let ((web-mode-enable-part-face nil))
              ad-do-it)
          ad-do-it))

      ;; make web-mode play nice with smartparens
      (setq web-mode-enable-auto-pairing nil)))
#+END_SRC
*** nxml mode
#+BEGIN_SRC emacs-lisp
(req-package nxml-mode
:config
(setq
 nxml-child-indent 4
 nxml-attribute-indent 4
 nxml-slash-auto-complete-flag t))
#+END_SRC

** Aesthetics
*** Rich minority
Hide minor modes from the mode lines

#+BEGIN_SRC emacs-lisp
  (req-package rich-minority
    :init
    (progn
      (rich-minority-mode 1)
      (setf rm-blacklist "")))
#+END_SRC
*** Smart mode line

#+BEGIN_SRC emacs-lisp
  (req-package smart-mode-line
    :init
    (progn
      (setq sml/no-confirm-load-theme t)
      (sml/setup)
      )
    :config
    (progn
      (setq sml/shorten-directory t)
      (setq sml/shorten-modes t)
      (setq sml/name-width 40)
      (setq sml/mode-width 'full)
      ))
#+END_SRC
*** Golden ratio
#+BEGIN_SRC emacs-lisp
  (req-package golden-ratio
    :config
    (progn
     (setq golden-ratio-extra-commands
           (append golden-ratio-extra-commands
                   '(evil-window-left
                     evil-window-right
                     evil-window-up
                     evil-window-down
                     select-window-0
                     select-window-1
                     select-window-2
                     select-window-3
                     select-window-4)))

     (defun spacemacs/toggle-golden-ratio ()
       "Toggle golden-ratio mode on and off."
       (interactive)
       (if (symbol-value golden-ratio-mode)
           (progn (golden-ratio-mode -1)(balance-windows))
         (golden-ratio-mode)
         (golden-ratio)))
     (evil-leader/set-key "tg" 'spacemacs/toggle-golden-ratio)))
#+END_SRC
*** Window numbering
#+BEGIN_SRC emacs-lisp
  (req-package window-numbering
    :require evil-leader
    :config
    (progn
      (evil-leader/set-key
        "0" 'select-window-0
        "1" 'select-window-1
        "2" 'select-window-2
        "3" 'select-window-3
        "4" 'select-window-4
        "5" 'select-window-5
        "6" 'select-window-6
        "7" 'select-window-7
        "8" 'select-window-8
        "9" 'select-window-9)

      (window-numbering-mode t)))
#+END_SRC
** ERC
#+BEGIN_SRC emacs-lisp
  (require 'erc)

  (setq erc-nick "nadavspi")
  (setq erc-autojoin-channels-alist '(("freenode.net" "#emacs")))

  (setq erc-hide-list '("JOIN" "PART" "QUIT"))


  ;; Timestamps on the left
  (setq erc-timestamp-only-if-changed-flag nil
        erc-timestamp-format "%H:%M "
        erc-fill-prefix "      "
        erc-insert-timestamp-function 'erc-insert-timestamp-left)
#+END_SRC
** Finish req-package
#+BEGIN_SRC emacs-lisp
(req-package-finish)
#+END_SRC
* Org mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            (lambda () (interactive)
              (org-indent-mode)
              (linum-mode 0)
              (visual-line-mode)))


  ;; Keys
  (evil-define-key 'normal org-mode-map
    ;; Todo
    "t" 'org-todo

    ;; Clocking
    "gxi" 'org-clock-in
    "gxo" 'org-clock-out
    "gxd" 'org-clock-display
    "gxr" 'org-clock-report)

  (evil-leader/set-key
    "oa" 'org-agenda
    "oc" 'org-capture
    "or" 'org-refile
    "oe" 'org-set-effort
    "os" 'org-schedule
    "ob" 'org-iswitchb
    "oh" 'helm-org-agenda-files-headings
    "oxc" 'org-clock-jump-to-current-clock
    "oH" 'helm-org-in-buffer-headings)

  (setq org-clock-clocktable-default-properties '(:maxlevel 4 :scope subtree))

  ;; Todo settings
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "MEETING(m)"))))

  (setq org-todo-keyword-faces
        '(("TODO" . (:foreground "DarkOrange1"))
          ("NEXT" . (:foreground "red"))
          ("DONE" . (:foreground "light sea green"))
          ("CANCELLED" . (:foreground "forest green"))
          ("WAITING" . (:foreground "light blue"))))


  ;; Prevent marking a task as DONE if any subtasks are open
  ;; (setq org-enforce-todo-dependencies t)

  ;; automatically assign tags to tasks based on state changes
  (setq org-todo-state-tags-triggers
        (quote (("CANCELLED" ("CANCELLED" . t))
                ("WAITING" ("WAITING" . t))
                ("HOLD" ("WAITING") ("HOLD" . t))
                (done ("WAITING") ("HOLD"))
                ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))

  ;; Agenda
  (setq org-agenda-files
        (list "~/Dropbox/Org/life.org"
              "~/Dropbox/Org/work.org"
              "~/Dropbox/Org/inbox.org"))

  (setq org-agenda-span 'day)

  ;; Enable syntax highlighting in babel src blocks
  (setq-default org-src-fontify-natively t)

  ;; (define-key evil-normal-state-map (kbd "gh") 'outline-up-heading)
  (define-key evil-normal-state-map (kbd "T") 'org-time-stamp)

  (mapcar (lambda (state)
            (evil-declare-key state org-mode-map
              (kbd "M-i") 'org-metaright
              (kbd "M-h") 'org-metaleft
              (kbd "M-e") 'org-metaup
              (kbd "M-n") 'org-metadown
              (kbd "M-I") 'org-shiftmetaright
              (kbd "M-H") 'org-shiftmetaleft
              (kbd "M-E") 'org-shiftmetaup
              (kbd "M-N") 'org-shiftmetadown))
          '(normal insert))
#+END_SRC

** Capture and refile
#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/Dropbox/Org")
  (setq org-default-notes-file "~/Dropbox/Org/inbox.org")

  (add-hook 'org-capture-mode-hook 'evil-insert-state)

  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
  ;; Allow refile to create parent tasks with confirmation
  (setq org-refile-allow-creating-parent-nodes 'confirm)

  ;; Targets include this file and any file contributing to the agenda
  (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9))))

  ;; Exclude DONE state tasks from refile targets
  (defun bh/verify-refile-target ()
    "Exclude todo keywords with a done state from refile targets"
    (not (member (nth 2 (org-heading-components)) org-done-keywords)))

  (setq org-refile-target-verify-function 'bh/verify-refile-target)

  (setq org-capture-templates
        (quote (("t" "TODO" entry (file "~/Dropbox/Org/inbox.org")
                 "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
                ("w" "TODO" entry (file+headline "~/Dropbox/Org/work.org" "Tasks")
                 "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
                ("n" "Note" entry (file "")
                 "* %? :NOTE:\n%U\n%a\n")
                ("f" "Food" entry (file+datetree "~/Dropbox/Org/food.org")
                 "* %?\n%U\n")
                ("m" "Meeting" entry (file+headline "~/Dropbox/Org/work.org" "Meetings")
                 "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t))))

#+END_SRC
** Agenda
Much taken from http://doc.norang.ca/org-mode.html#CustomAgendaViews
*** Helpers
#+BEGIN_SRC emacs-lisp
  ;; Enable evil-leader in agenda
  (setq evil-leader/no-prefix-mode-rx '("org-agenda-mode"))

  (setq org-agenda-span 'day)

  (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 7 :compact t :narrow 80))

  (defun bh/find-project-task ()
    "Move point to the parent (project) task if any"
    (save-restriction
      (widen)
      (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
        (while (org-up-heading-safe)
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (goto-char parent-task)
        parent-task)))

  (defun bh/is-project-p ()
    "Any task with a todo keyword subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task has-subtask))))

  (defun bh/is-project-subtree-p ()
    "Any task with a todo keyword that is in a project subtree.
    Callers of this function already widen the buffer view."
    (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                (point))))
      (save-excursion
        (bh/find-project-task)
        (if (equal (point) task)
            nil
          t))))

  (defun bh/is-task-p ()
    "Any task with a todo keyword and no subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task (not has-subtask)))))

  (defun bh/is-subproject-p ()
    "Any task which is a subtask of another project"
    (let ((is-subproject)
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (while (and (not is-subproject) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq is-subproject t))))
      (and is-a-task is-subproject)))

  (defun bh/list-sublevels-for-projects-indented ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
      This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels 'indented)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defun bh/list-sublevels-for-projects ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
      This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels t)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defvar bh/hide-scheduled-and-waiting-next-tasks t)

  (defun bh/toggle-next-task-display ()
    (interactive)
    (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
    (when  (equal major-mode 'org-agenda-mode)
      (org-agenda-redo))
    (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

  (defun bh/skip-stuck-projects ()
    "Skip trees that are not stuck projects"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  nil
                next-headline)) ; a stuck project, has subtasks but no next task
          nil))))

  (defun bh/skip-non-stuck-projects ()
    "Skip trees that are not stuck projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  next-headline
                nil)) ; a stuck project, has subtasks but no next task
          next-headline))))

  (defun bh/skip-non-projects ()
    "Skip trees that are not projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (if (save-excursion (bh/skip-non-stuck-projects))
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              nil)
             ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
              nil)
             (t
              subtree-end))))
      (save-excursion (org-end-of-subtree t))))

  (defun bh/skip-project-trees-and-habits ()
    "Skip trees that are projects"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits-and-single-tasks ()
    "Skip trees that are projects, tasks that are habits, single non-project tasks"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((and bh/hide-scheduled-and-waiting-next-tasks
               (member "WAITING" (org-get-tags-at)))
          next-headline)
         ((bh/is-project-p)
          next-headline)
         ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
          next-headline)
         (t
          nil)))))

  (defun bh/skip-project-tasks-maybe ()
    "Show tasks related to the current restriction.
    When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
    When not restricted, skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max))))
             (limit-to-project (marker-buffer org-agenda-restrict-begin)))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((and (not limit-to-project)
               (bh/is-project-subtree-p))
          subtree-end)
         ((and limit-to-project
               (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-project-tasks ()
    "Show non-project tasks.
    Skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((bh/is-project-subtree-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-project-tasks ()
    "Show project tasks.
    Skip project and sub-project tasks, habits, and loose non-project tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((and (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         ((not (bh/is-project-subtree-p))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits ()
    "Skip trees that are projects and tasks that are habits"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-subprojects ()
    "Skip trees that are not projects"
    (let ((next-headline (save-excursion (outline-next-heading))))
      (if (bh/is-subproject-p)
          nil
        next-headline)))
#+END_SRC
*** Custom views
#+BEGIN_SRC emacs-lisp
  ;; Do not dim blocked tasks
  (setq org-agenda-dim-blocked-tasks nil)

  ;; Compact the block agenda view
  (setq org-agenda-compact-blocks t)

  (setq org-agenda-window-setup 'current-window)

  (setq org-agenda-skip-scheduled-if-done t)

  ;; Custom agenda command definitions
  (setq org-agenda-custom-commands
        (quote ((" " "Agenda"
                 ((agenda "" nil)
                  (tags "REFILE"
                        ((org-agenda-overriding-header "Tasks to Refile")
                         (org-tags-match-list-sublevels nil)))
                  (tags-todo "-HOLD-CANCELLED/!"
                             ((org-agenda-overriding-header "Projects")
                              (org-agenda-skip-function 'bh/skip-non-projects)
                              (org-tags-match-list-sublevels nil)
                              (org-agenda-sorting-strategy
                               '(category-keep))))
                  (tags-todo "-CANCELLED+WAITING|HOLD/!"
                             ((org-agenda-overriding-header (concat "Waiting and Postponed Tasks"
                                                                    (if bh/hide-scheduled-and-waiting-next-tasks
                                                                        ""
                                                                      " (including WAITING and SCHEDULED tasks)")))
                              (org-agenda-skip-function 'bh/skip-non-tasks)
                              (org-tags-match-list-sublevels nil)
                              (org-agenda-todo-ignore-scheduled bh/hide-scheduled-and-waiting-next-tasks)
                              (org-agenda-todo-ignore-deadlines bh/hide-scheduled-and-waiting-next-tasks))))
                 nil))))
#+END_SRC
*** Narrowing
#+BEGIN_SRC emacs-lisp
  (evil-leader/set-key
    "ot"  'bh/org-todo
    "ow"  'bh/widen)

  (defun bh/org-todo (arg)
    (interactive "p")
    (if (equal arg 4)
        (save-restriction
          (bh/narrow-to-org-subtree)
          (org-show-todo-tree nil))
      (bh/narrow-to-org-subtree)
      (org-show-todo-tree nil)))

  (defun bh/widen ()
    (interactive)
    (if (equal major-mode 'org-agenda-mode)
        (progn
          (org-agenda-remove-restriction-lock)
          (when org-agenda-sticky
            (org-agenda-redo)))
      (widen)))

  (add-hook 'org-agenda-mode-hook
            '(lambda () (org-defkey org-agenda-mode-map "W" (lambda () (interactive) (setq bh/hide-scheduled-and-waiting-next-tasks t) (bh/widen))))
            'append)

  (defun bh/restrict-to-file-or-follow (arg)
    "Set agenda restriction to 'file or with argument invoke follow mode.
  I don't use follow mode very often but I restrict to file all the time
  so change the default 'F' binding in the agenda to allow both"
    (interactive "p")
    (if (equal arg 4)
        (org-agenda-follow-mode)
      (widen)
      (bh/set-agenda-restriction-lock 4)
      (org-agenda-redo)
      (beginning-of-buffer)))

  (add-hook 'org-agenda-mode-hook
            '(lambda () (org-defkey org-agenda-mode-map "F" 'bh/restrict-to-file-or-follow))
            'append)

  (defun bh/narrow-to-org-subtree ()
    (widen)
    (org-narrow-to-subtree)
    (save-restriction
      (org-agenda-set-restriction-lock)))

  (defun bh/narrow-to-subtree ()
    (interactive)
    (if (equal major-mode 'org-agenda-mode)
        (progn
          (org-with-point-at (org-get-at-bol 'org-hd-marker)
            (bh/narrow-to-org-subtree))
          (when org-agenda-sticky
            (org-agenda-redo)))
      (bh/narrow-to-org-subtree)))

  (add-hook 'org-agenda-mode-hook
            '(lambda () (org-defkey org-agenda-mode-map "N" 'bh/narrow-to-subtree))
            'append)

  (defun bh/narrow-up-one-org-level ()
    (widen)
    (save-excursion
      (outline-up-heading 1 'invisible-ok)
      (bh/narrow-to-org-subtree)))

  (defun bh/get-pom-from-agenda-restriction-or-point ()
    (or (and (marker-position org-agenda-restrict-begin) org-agenda-restrict-begin)
        (org-get-at-bol 'org-hd-marker)
        (and (equal major-mode 'org-mode) (point))
        org-clock-marker))

  (defun bh/narrow-up-one-level ()
    (interactive)
    (if (equal major-mode 'org-agenda-mode)
        (progn
          (org-with-point-at (bh/get-pom-from-agenda-restriction-or-point)
            (bh/narrow-up-one-org-level))
          (org-agenda-redo))
      (bh/narrow-up-one-org-level)))

  (add-hook 'org-agenda-mode-hook
            '(lambda () (org-defkey org-agenda-mode-map "U" 'bh/narrow-up-one-level))
            'append)

  (defun bh/narrow-to-org-project ()
    (widen)
    (save-excursion
      (bh/find-project-task)
      (bh/narrow-to-org-subtree)))

  (defun bh/narrow-to-project ()
    (interactive)
    (if (equal major-mode 'org-agenda-mode)
        (progn
          (org-with-point-at (bh/get-pom-from-agenda-restriction-or-point)
            (bh/narrow-to-org-project)
            (save-excursion
              (bh/find-project-task)
              (org-agenda-set-restriction-lock)))
          (org-agenda-redo)
          (beginning-of-buffer))
      (bh/narrow-to-org-project)
      (save-restriction
        (org-agenda-set-restriction-lock))))

  (add-hook 'org-agenda-mode-hook
            '(lambda () (org-defkey org-agenda-mode-map "P" 'bh/narrow-to-project))
            'append)

  (defvar bh/project-list nil)

  (defun bh/view-next-project ()
    (interactive)
    (let (num-project-left current-project)
      (unless (marker-position org-agenda-restrict-begin)
        (goto-char (point-min))
                                          ; Clear all of the existing markers on the list
        (while bh/project-list
          (set-marker (pop bh/project-list) nil))
        (re-search-forward "Tasks to Refile")
        (forward-visible-line 1))

                                          ; Build a new project marker list
      (unless bh/project-list
        (while (< (point) (point-max))
          (while (and (< (point) (point-max))
                      (or (not (org-get-at-bol 'org-hd-marker))
                          (org-with-point-at (org-get-at-bol 'org-hd-marker)
                            (or (not (bh/is-project-p))
                                (bh/is-project-subtree-p)))))
            (forward-visible-line 1))
          (when (< (point) (point-max))
            (add-to-list 'bh/project-list (copy-marker (org-get-at-bol 'org-hd-marker)) 'append))
          (forward-visible-line 1)))

                                          ; Pop off the first marker on the list and display
      (setq current-project (pop bh/project-list))
      (when current-project
        (org-with-point-at current-project
          (setq bh/hide-scheduled-and-waiting-next-tasks nil)
          (bh/narrow-to-project))
                                          ; Remove the marker
        (setq current-project nil)
        (org-agenda-redo)
        (beginning-of-buffer)
        (setq num-projects-left (length bh/project-list))
        (if (> num-projects-left 0)
            (message "%s projects left to view" num-projects-left)
          (beginning-of-buffer)
          (setq bh/hide-scheduled-and-waiting-next-tasks t)
          (error "All projects viewed.")))))

  (add-hook 'org-agenda-mode-hook
            '(lambda () (org-defkey org-agenda-mode-map "V" 'bh/view-next-project))
            'append)

#+END_SRC
**** Limiting the agenda to a subtree
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-agenda-mode-hook
            '(lambda () (org-defkey org-agenda-mode-map "\C-c\C-x<" 'bh/set-agenda-restriction-lock))
            'append)

  (defun bh/set-agenda-restriction-lock (arg)
    "Set restriction lock to current task subtree or file if prefix is specified"
    (interactive "p")
    (let* ((pom (bh/get-pom-from-agenda-restriction-or-point))
           (tags (org-with-point-at pom (org-get-tags-at))))
      (let ((restriction-type (if (equal arg 4) 'file 'subtree)))
        (save-restriction
          (cond
           ((and (equal major-mode 'org-agenda-mode) pom)
            (org-with-point-at pom
              (org-agenda-set-restriction-lock restriction-type))
            (org-agenda-redo))
           ((and (equal major-mode 'org-mode) (org-before-first-heading-p))
            (org-agenda-set-restriction-lock 'file))
           (pom
            (org-with-point-at pom
              (org-agenda-set-restriction-lock restriction-type))))))))

  ;; Limit restriction lock highlighting to the headline only
  (setq org-agenda-restriction-lock-highlight-subtree nil)

#+END_SRC
** Clock
#+BEGIN_SRC emacs-lisp
  ;; Persistent clocking
  (setq org-clock-persist 'history)
  (org-clock-persistence-insinuate)

  ;; Resume clocking task on clock-in if the clock is open
  (setq org-clock-in-resume t)
  ;; Change tasks to NEXT when clocking in
  (setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
  ;; Do not prompt to resume an active clock
  (setq org-clock-persist-query-resume nil)
  ;; Enable auto clock resolution for finding open clocks
  (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
  ;; Separate drawers for clocking and logs
  (setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
  ;; Save clock data and state changes and notes in the LOGBOOK drawer
  (setq org-clock-into-drawer t)
  ;; Include current clocking task in clock reports
  (setq org-clock-report-include-clocking-task t)
  ;; this removes clocked tasks with 0:00 duration
  (setq org-clock-out-remove-zero-time-clocks t)

  (defun bh/clock-in-to-next (kw)
    "Switch a task from TODO to NEXT when clocking in.
  Skips capture tasks, projects, and subprojects.
  Switch projects and subprojects from NEXT back to TODO"
    (when (not (and (boundp 'org-capture-mode) org-capture-mode))
      (cond
       ((and (member (org-get-todo-state) (list "TODO"))
             (bh/is-task-p))
        "NEXT")
       ((and (member (org-get-todo-state) (list "NEXT"))
             (bh/is-project-p))
        "TODO"))))
#+END_SRC
** Columns and estimates
#+BEGIN_SRC emacs-lisp
  ;; Set default column view headings: Task Effort Clock_Summary
  (setq org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")

  ;; global Effort estimate values
  ;; global STYLE property values for completion
  (setq org-global-properties (quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                      ("STYLE_ALL" . "habit"))))
#+END_SRC
** Archiving
#+BEGIN_SRC emacs-lisp
  (setq org-archive-mark-done nil)
  (setq org-archive-location "%s_archive::* Archived Tasks")

  (defun bh/skip-non-archivable-tasks ()
    "Skip trees that are not available for archiving"
    (save-restriction
      (widen)
      ;; Consider only tasks with done todo headings as archivable candidates
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
            (subtree-end (save-excursion (org-end-of-subtree t))))
        (if (member (org-get-todo-state) org-todo-keywords-1)
            (if (member (org-get-todo-state) org-done-keywords)
                (let* ((daynr (string-to-int (format-time-string "%d" (current-time))))
                       (a-month-ago (* 60 60 24 (+ daynr 1)))
                       (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
                       (this-month (format-time-string "%Y-%m-" (current-time)))
                       (subtree-is-current (save-excursion
                                             (forward-line 1)
                                             (and (< (point) subtree-end)
                                                  (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
                  (if subtree-is-current
                      subtree-end ; Has a date in this month or last month, skip it
                    nil))  ; available to archive
              (or subtree-end (point-max)))
          next-headline))))
#+END_SRC
** Aesthetics
#+BEGIN_SRC emacs-lisp
  ;; Hides blank lines between headings
  (setq org-cycle-separator-lines 0)

  (setq org-log-done (quote time))
  (setq org-log-into-drawer t)
  (setq org-log-state-notes-insert-after-drawers nil)

  (setq org-return-follows-link t)
#+END_SRC
* Shells
** General term stuff
#+BEGIN_SRC emacs-lisp
  (defun oleh-term-exec-hook ()
    (let* ((buff (current-buffer))
           (proc (get-buffer-process buff)))
      (set-process-sentinel
       proc
       `(lambda (process event)
          (if (string= event "finished\n")
              (kill-buffer ,buff))))))

  (add-hook 'term-exec-hook 'oleh-term-exec-hook)

  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
  (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)

#+END_SRC
** Ansi-term
#+BEGIN_SRC emacs-lisp
  (defadvice ansi-term (after advise-ansi-term-coding-system)
    (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
  (ad-activate 'ansi-term)
#+END_SRC

** Eshell
#+BEGIN_SRC emacs-lisp
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
  current buffer's file. The eshell is renamed to match that
  directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert (concat "ls"))
      (eshell-send-input)))

  (evil-leader/set-key "s" 'eshell-here)

  (defun eshell/x ()
    (insert "exit")
    (eshell-send-input)
    (delete-window))
#+END_SRC
* Helper functions
** Adjust font size
Courtesy of spacemacs

#+BEGIN_SRC emacs-lisp
  (defun spacemacs/scale-font-size-overlay-map ()
    "Set a temporary overlay map to easily change the font size."
    (set-temporary-overlay-map
     (let ((map (make-sparse-keymap)))
       (define-key map (kbd "+") 'spacemacs/scale-up-font)
       (define-key map (kbd "-") 'spacemacs/scale-down-font)
       (define-key map (kbd "=") 'spacemacs/reset-font-size)
       map) t))

  (defun spacemacs/font-scaling-micro-state-doc ()
    "Display a short documentation in the mini buffer."
    (message "Scale Font micro-state:
    + to scale up
    - to scale down
    = to reset
  Press any other key to exit."))

  (spacemacs/font-scaling-micro-state-doc)

  (defun spacemacs/scale-up-or-down-font-size (direction)
    "Scale the font. If DIRECTION is positive or zero the font is scaled up,
  otherwise it is scaled down."
    (interactive)
    (let ((scale 0.5))
      (if (eq direction 0)
          (text-scale-set 0)
        (if (< direction 0)
            (text-scale-decrease scale)
          (text-scale-increase scale))))
    (spacemacs/scale-font-size-overlay-map)
    (spacemacs/font-scaling-micro-state-doc))

  (defun spacemacs/scale-up-font ()
    "Scale up the font."
    (interactive)
    (spacemacs/scale-up-or-down-font-size 1))

  (defun spacemacs/scale-down-font ()
    "Scale up the font."
    (interactive)
    (spacemacs/scale-up-or-down-font-size -1))

  (defun spacemacs/reset-font-size ()
    "Reset the font size."
    (interactive)
    (spacemacs/scale-up-or-down-font-size 0))


  (evil-leader/set-key
    "="  'spacemacs/reset-font-size
    "+"  'spacemacs/scale-up-font
    "-"  'spacemacs/scale-down-font)
#+END_SRC
** Cleanup buffer
Useful stuff from Magnars

#+BEGIN_SRC emacs-lisp
(defun untabify-buffer ()
  (interactive)
  (untabify (point-min) (point-max)))

(defun indent-buffer ()
  (interactive)
  (indent-region (point-min) (point-max)))

(defun cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a buffer.
Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (untabify-buffer)
  (delete-trailing-whitespace)
  (indent-buffer))

(evil-leader/set-key "c" 'cleanup-buffer)
#+END_SRC
** Linewise
Some useful mappings inspired by unimpaired.vim
#+BEGIN_SRC emacs-lisp
(evil-define-command evil-linewise-blank-lines-above (&optional count argument)
  "Inserts blank lines above the cursor"
  (interactive "p")
  (evil-open-above count)
  (evil-normal-state)
  (evil-next-line)
  (message nil))

(evil-define-command evil-linewise-blank-lines-below (&optional count argument)
  "Inserts blank lines below the cursor"
  (interactive "p")
  (evil-open-below count)
  (evil-normal-state)
  (evil-previous-line count)
  (message nil))

(evil-define-command evil-linewise-move-text-down (&optional count argument)
  "Moves line arg lines down. Uses move-text.el"
  (interactive "p")
  (move-text-down count))

(evil-define-command evil-linewise-move-text-up (&optional count argument)
  "Moves line arg lines up. Uses move-text.el"
  (interactive "p")
  (move-text-up count))

(evil-define-command evil-linewise-paste-newline-below
  "Pastes in a new line below"
  (interactive)
  ;; (move-end-of-line 1)
  ;; (newline-and-indent)
  (evil-open-below 1)
  (evil-normal-state)
  (evil-paste-after 1)
  (message nil))

(evil-define-command evil-linewise-paste-newline-above
  "Pastes in a new line above"
  (interactive)
  (evil-open-above 1)
  (evil-normal-state)
  (evil-paste-after 1)
  (message nil))

(evil-define-command evil-linewise-next-buffer
  "Goes to the next buffer"
  (interactive)
  (evil-next-buffer 1))

(evil-define-command evil-linewise-previous-buffer
  "Goes to the previous buffer"
  (interactive)
  (evil-prev-buffer 1))

(define-key evil-normal-state-map (kbd "[ SPC") 'evil-linewise-blank-lines-above)
(define-key evil-normal-state-map (kbd "] SPC") 'evil-linewise-blank-lines-below)

(define-key evil-normal-state-map (kbd "[ e") 'evil-linewise-move-text-up)
(define-key evil-normal-state-map (kbd "] e") 'evil-linewise-move-text-down)

(define-key evil-normal-state-map (kbd "[ p") 'evil-linewise-paste-newline-above)
(define-key evil-normal-state-map (kbd "] p") 'evil-linewise-paste-newline-below)

(define-key evil-normal-state-map (kbd "[ b") 'evil-linewise-next-buffer)
(define-key evil-normal-state-map (kbd "] b") 'evil-linewise-previous-buffer)
#+END_SRC
** CSS helpers
*** Duplicate selector

#+BEGIN_SRC emacs-lisp
(defun duplicate-css-selector ()
  "Duplicates next selector and comma separates them"
  (interactive)
  (search-forward "{")
  (backward-delete-char 2)
  (insert ",")
  (move-beginning-of-line 1)
  (kill-line)
  (yank)
  (open-line 1)
  (next-line 1)
  (yank)
  (backward-delete-char 1)
  (insert " {"))
(define-key evil-normal-state-map (kbd "g d s") 'duplicate-css-selector)
#+END_SRC

*** Duplicate property

Duplicates a property and flips its direction. E.g., padding-left -> padding-right
#+BEGIN_SRC emacs-lisp
(defun duplicate-opposite-css-property ()
  "Duplicates a CSS declaration and changes the property's direction from left to right, top to bottom, etc."
  (interactive)
  (evil-yank-line (point-at-bol) (point-at-eol) 'line)
  (evil-paste-after 1)
  (evil-forward-word-begin 2)
  (let ((x (current-word t t)))
    (kill-word 1)
    (cond ((equal "left" x) (insert "right"))
          ((equal "right" x) (insert "left"))
          ((equal "top" x) (insert "bottom"))
          ((equal "bottom" x) (insert "top")))))
(define-key evil-normal-state-map (kbd "g d p") 'duplicate-opposite-css-property)
#+END_SRC

** Magento
*** Toggle template hints
Uses magerun to toggle template hints

#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map (kbd "g m h")
  (lambda ()
    (interactive)
    (start-process "magerun"
                   (get-buffer-create "*magerun*")
                   "magerun" "dev:template-hints")
    (message "Toggling template hints")))
#+END_SRC
** Org clock statusbar app
https://github.com/koddo/org-clock-statusbar-app

#+BEGIN_SRC emacs-lisp
(add-hook 'org-clock-in-hook (lambda () (call-process "/usr/bin/osascript" nil 0 nil "-e" (concat "tell application \"org-clock-statusbar\" to clock in \"" org-clock-current-task "\""))))
(add-hook 'org-clock-out-hook (lambda () (call-process "/usr/bin/osascript" nil 0 nil "-e" "tell application \"org-clock-statusbar\" to clock out")))
#+END_SRC

** Elisp slime navigation

Turn on eldoc and slime nav for elisp and bind K to describe the thing at point.
From here: http://nathantypanski.com/blog/2014-08-03-a-vim-like-emacs-config.html
#+BEGIN_SRC emacs-lisp
  (defun my-lisp-hook ()
    (eldoc-mode))

  (add-hook 'emacs-lisp-mode-hook 'my-lisp-hook)

  ;; (evil-define-key 'normal emacs-lisp-mode-map (kbd "K") 'elisp-slime-nav-describe-elisp-thing-at-point)
#+END_SRC
